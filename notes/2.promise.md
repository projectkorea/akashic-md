# Promise

## 1. What is `promise`?

-   `Promise` is a built-in Javascript `object` for asynchronous.
-   프로미스 객체는 콜백지옥을 해결하고, 여러개의 비동기 처리를 효과적으로 처리한다.
-   정해진 장시간의 기능을 수행하다가,
    -   정상적으로 작동했다면 **성공의 메세지 + 결과값**을 전달해주고,
    -   예상치 못한 결과가 나왔을 때 **error**를 전달한다.

    #### 프로미스의 기본 구조
-  ```js
    new Promise(executor)
    ```
    - `Promise 객체`는 `new` 키워드와 `Promise` 생성자를 사용해 만든다. 
    - `Promise` 생성자는 매개변수로 executor 라는 **콜백 함수**를 받는다. 
    - `executor`는 `Promise 객체`를 반환하기도 전에 **바로 실행**된다.
  - 
    ```js
    const myFirstPromise = new Promise((resolve, reject) => {
    // do something asynchronous which eventually calls either:
    //
    //   resolve(someValue)        // fulfilled
    // or
    //   reject("failure reason")  // rejected
    });
    ```
    
    - `executor`는 **`resolve` 함수** 와 **`reject` 함수**를 인자로 받는다.

## 2. state, producer / consumer

### 1) state
   1. pending: 기능 수행중인 상태
   2. fulfilled: 성공
   3. rejected: 실패

**fullfilled**
```js
const promise = new Promise(function(resolve, reject){
    resolve('value')
})
promise.then(value=>console.log(value))
```
- 콜백 함수의 인자 `resolve()` 를 실행하면 **Fulfilled(이행) 상태의 Promise 객체를 리턴한다**.
- 이행 상태가 되면 `.then()` 을 이용하여 처리 결과 값을 받아 처리할 수 있다.

**rejected**
```js
new Promise(function(resolve, reject){
    reject(new Error('Error occured!'))
})
promise.catch(err=>console.log(err))
```
- 콜백 함수의 인자 `reject()` 를 실행하면 **Rejected(실패) 상태의 Promise 객체를 리턴한다**
- 실패 상태가 되면 실패 처리 결과 값을 후속 처리 메소드 `catch()` 로 받아 처리할 수 있다.


### 2) producer / consumer

  1) producer: `promise` 오브젝트
  2) consumer
     - `.then()`, `.catch()`, `.finally()`
     - `Promise 객체`의 상태에 따라 처리 할 후속 처리 메소드를 일컫는다.

**Producer 정의**

```js
const promise = new Promise((resolve, reject) => {
    //doing some heavy work(network, read files)
    console.log('...');
    setTimeout(() => {
        resolve('junha');
    }, 2000);
    reject(new Error('no network'));
});
```

**Consumer 정의**

```js
promise
    .then((value) => {
        console.log(value);
    })
    .catch((error) => {
        console.log(error);
    })
    .finally(() => {
        console.log('finally');
    });
```
#### `.then(onFulfilled, onRejected);`
- `then` 메소드는 두 개의 콜백 함수를 인자로 받는다. 
- 첫 번째 콜백 함수는 Fulfilled(이행, resolve 함수가 호출된 상태) 시 호출되고
- 두 번째 함수는 Reject(실패, reject 함수가 호출된 상태) 시 호출된다.
- then 메소드는 Promise를 반환한다.

#### `.catch(onRejected);`
- 예외(비동기 처리 또는 then 메소드에서 발생한 에러)가 발생하면 호출된다.
- catch 메소드는 Promise를 반환한다.

#### `.finally(onFinally);`
- Promise 가 처리되면 상태에 상관없이 지정된 콜백 함수가 실행된다.


## 3. Promise Chaining

- `.then()`, `.catch()`는 `Promise`를 리턴하기 때문에 `.then() | .catch()`로 체이닝 할 수 있다.

**체이닝 예시 코드**

```js
const fetchNumber = new Promise((resolve, reject) => {
    setTimeout(() => resolve(1), 1000);
});

fetchNumber
    .then((num) => num * 2)
    .then((num) => num * 3)
    .then((num) => {
        return new Promise((resolve, reject) => {
            setTimeout(() => resolve(num - 1), 1000);
        });
    });
    .then(num => console.log(num))
```

- `.then()`이 Promise 객체를 반환하기 때문에 체이닝이 가능하다.

## 4. Error Handling

#### 1) `then()` 의 두번째 인자를 활용하는 방법

```js
getData()
    .then(onFullfiled, onRejected);
```

#### 2) `catch()`를 이용하는 방법

```js
getData()
    .then()
    .catch();
```

```js
getData().catch(function (err) {
  console.log(err);
});

getData().then(undefined, function (err) {
  console.log(err);
});
```
- `catch()`는 `then(undefined, onRejexted)`를 호출한다.

#### 3) `.catch()` 사용을 권장한다.

**예시) `then()`의 첫번째 콜백 함수 내부에서 오류가 나는 경우**

```js
function getData() {
  return new Promise(function (resolve, reject) {
    resolve("hi");
  });
}
```

```js
getData().then(
  function (result) {
    console.log(result);
    throw new Error("Error in then()");
    // Uncaught (in promise) Error: Error in then()
  },
  function (err) {
    console.log("then error : ", err);
    // this can't caught "Error in then()" Error
  }
);
```
- `then()` 의 첫 번째 콜백 함수 내부에서 오류가 나는 경우 잡아내지 못한다.

```js
getData()
  .then(function (result) {
    console.log(result); // hi
    throw new Error("Error in then()");
  })
  .catch(function (err) {
    console.log("then error : ", err);
    // then error :  Error: Error in then()
  });
```

- `.catch()` 메소드를 모든 `.then()` 메소드를 호출한 이후에 호출하면, 비동기 처리에서 발생한 에러(reject 함수가 호출된 상태)뿐만 아니라 then 메소드 안에서 발생한 에러까지 모두 캐치할 수 있다.
- 따라서 가독성도 좋고 더 많은 예외 처리 상황을 위해 `catch()` 로 에러 처리를 해주는 것이 좋다.

#### 4) 재미있는 예시

```js
const getHen = () => {
    new Promise((resolve, reject) => {
        setTimeout(() => resolve('🐔'), 1000);
    });
};

const getEgg = (hen) =>
    new Promise((resolve, reject) => {
        setTimeout(() => resolve(`${hen} => '🥚'`), 1000);
    });

const getFry = (egg) =>
    new Promise((resolve, reject) => {
        setTimeout(() => resolve(`${egg} => '🥯'`), 1000);
    });

getHen()
    .then((hen) => getEgg(hen))
    .catch((error) => {
        return `${egg} => '🍕'`;
    })
    .then((egg) => getFry(egg))
    .then((meal) => console.log(meal));
```

```js
.then((hen) => getEgg(hen))
.then(getEgg)
// 아규먼트가 동일할 경우 생략이 가능하다.
```